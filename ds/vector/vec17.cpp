/* #FH #CC //z 17-07-11 10:33:47 L.173'48373 T1888754067.K.F3385784024+----+----+----+----+----+
+  0.FileInfo: +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
        File : E:\MyDoc\GitHub\Zds\ds\vector\vec17.cpp.F3385784024----+----+----+----+----+----+
       Motto : No one can make you feel inferior without your consent.+----+----+----+----+----+
       Motto : The death of fear is in doing what you fear to do.+----+----+----+----+----+----+
       Motto : It's hard to beat a person who never gives up.----+----+----+----+----+----+----+
       Motto : Take what you do seriously. Not yourself.----+----+----+----+----+----+----+----+
       Motto : Life begins where your comfort zone ends.----+----+----+----+----+----+----+----+
       Motto : To know and not do, is not yet to know.-+----+----+----+----+----+----+----+----+
       Motto : The more you do , the more you can do.--+----+----+----+----+----+----+----+----+
       Motto : Do what you do best, better.--+----+----+----+----+----+----+----+----+----+----+
       Motto : Get Your Hands Dirty.----+----+----+----+----+----+----+----+----+----+----+----+
      Author : CopyRight (C) 2017 126.org@gmail.com (K->30,T5,M&M,W)--+----+----+----+----+----+

+  1.ID & Desc: ----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+

+  2.Req & Repro: --+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+

+  3.Folder & File: +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+

+  4.Cause & Solution: --+----+----+----+----+----+----+----+----+----+----+----+----+----+----+

+  5.Todo & Done: --+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+

+  6.Commit: --+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+

+  7.Issue: ---+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+

+  8.Summary: -+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+

+  9.Misc: ----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+

***********************************************************************************************/

#region 07-11 R#.0    @Ver.Info
       Zey_S : //z 17-07-11 10:33:47 L.173'48373 T1888754067.K ~0   --+----+----+----+----+----+
		R#
		//k
		zsum
       Zey_E : //z 17-07-11 10:33:47 L.173'48373 T1888754067.K ~0   --+----+----+----+----+----+
       Zcl_S : //z 17-07-11 10:33:47 L.173'48373 T1888754067.K ~0   --+----+----+----+----+----+
       Zcl_E : //z 17-07-11 10:33:47 L.173'48373 T1888754067.K ~0   --+----+----+----+----+----+
      ZdoIdx : //z 17-07-11 10:33:47 L.173'48373 T1888754067.K ~0   --+----+----+----+----+----+
      KmtIdx : //z 17-07-11 18:10:05 L.173'20995 T3628083440.K ~23  --+----+----+----+----+----+
     TimeCnt : //z 17-07-11 17:47:10 L.173'22370 T2340424821.K ~5   --+----+----+----+----+----+
     Reg.Cnt : //z 17-07-11 17:47:09 L.173'22371 T2340424797.K ~13  --+----+----+----+----+----+
     File.Op : //z 17-07-11 10:33:47 L.173'48373 T1888754067.K ~0   --+----+----+----+----+----+
     Version : //z 17-07-12 18:05:21 L.172'21279 T3694878643.K ~403     R+.13   L+.539  --+----+
     #21  V+ : //z 17-07-12 15:19:52 L.172'31208 T4116771801.K ~399     R+.13   L+.538  
     #20  V+ : //z 17-07-11 18:10:05 L.173'20995 T3628083440.K ~380     R+.13   L+.525  
     #19  V+ : //z 17-07-11 17:47:19 L.173'22361 T2340424830.K ~361     R+.13   L+.502  
     #18  R+ : //z 17-07-11 17:47:09 L.173'22371 T2340424797.K ~358     R+.13   L+.501  V+.358  
     #18  V+ : //z 17-07-11 17:43:26 L.173'22594 T2340281112.K ~342     R+.12   L+.461  
     #17  V+ : //z 17-07-11 17:39:07 L.173'22853 T2339310748.K ~323     R+.12   L+.448  
     #16  R+ : //z 17-07-11 17:38:24 L.173'22896 T2339274874.K ~317     R+.12   L+.447  V+.317  
     #16  V+ : //z 17-07-11 17:32:47 L.173'23233 T2339059321.K ~304     R+.11   L+.440  
     #15  R+ : //z 17-07-11 17:30:08 L.173'23392 T2338987316.K ~296     R+.11   L+.431  V+.296  
     #15  V+ : //z 17-07-11 17:27:04 L.173'23576 T2338052950.K ~285     R+.10   L+.420  
     #14  V+ : //z 17-07-11 17:00:41 L.173'25159 T2335429678.K ~266     R+.10   L+.407  
     #13  R+ : //z 17-07-11 16:59:22 L.173'25238 T1050214682.K ~253     R+.10   L+.387  V+.253  
     #13  V+ : //z 17-07-11 16:26:49 L.173'27191 T1046549181.K ~247     R+.9    L+.379  
     #12  V+ : //z 17-07-11 16:19:50 L.173'27610 T1045471095.K ~228     R+.9    L+.323  
     #11  V+ : //z 17-07-11 15:31:45 L.173'30495 T4051054740.K ~209     R+.9    L+.305  
     #10  R+ : //z 17-07-11 15:31:41 L.173'30499 T4051054736.K ~207     R+.9    L+.306  V+.207  
     #10  V+ : //z 17-07-11 15:19:27 L.173'31233 T4048970330.K ~190     R+.8    L+.298  
     #9   V+ : //z 17-07-11 11:38:36 L.173'44484 T3180401687.K ~171     R+.8    L+.275  
     #8   V+ : //z 17-07-11 11:25:50 L.173'45250 T3179108015.K ~152     R+.8    L+.286  
     #7   R+ : //z 17-07-11 11:24:03 L.173'45357 T3179071916.K ~138     R+.8    L+.273  V+.138  
     #7   V+ : //z 17-07-11 11:13:12 L.173'46008 T3177850090.K ~133     R+.7    L+.263  
     #6   R+ : //z 17-07-11 11:11:36 L.173'46104 T3177778286.K ~114     R+.7    L+.250  V+.114  
     #5   V+ : //z 17-07-11 11:02:14 L.173'46666 T3176628234.K ~95      R+.6    L+.209  
     #4   R+ : //z 17-07-11 11:01:40 L.173'46700 T3176592392.K ~91      R+.6    L+.209  V+.91   
     #4   R+ : //z 17-07-11 11:00:49 L.173'46751 T3176556464.K ~84      R+.5    L+.193  V+.84   
     #4   V+ : //z 17-07-11 10:58:58 L.173'46862 T1891305628.K ~76      R+.4    L+.177  
     #3   R+ : //z 17-07-11 10:58:57 L.173'46863 T1891305627.K ~75      R+.4    L+.177  V+.75   
     #3   V+ : //z 17-07-11 10:56:52 L.173'46988 T1891233748.K ~57      R+.3    L+.157  
     #2   R+ : //z 17-07-11 10:56:48 L.173'46992 T1891233721.K ~54      R+.3    L+.156  V+.54   
     #2   R+ : //z 17-07-11 10:52:41 L.173'47239 T1891089966.K ~43      R+.2    L+.86   V+.43   
     #2   V+ : //z 17-07-11 10:39:47 L.173'48013 T1888969689.K ~38      R+.1    L+.97   
     #1   V+ : //z 17-07-11 10:35:53 L.173'48247 T1888825970.K ~19      R+.1    L+.99   
     #0   R+ : //z 17-07-11 10:33:52 L.173'48368 T1888754095.K ~3       R+.1    L+.64   V+.3    
     Zndex_S : //z 17-07-11 10:33:47 L.173'48373 T1888754067.K ~0   --+----+----+----+----+----+
      L98 ,  1: 07-11 R#.2    @第2017.07月总结
      L105,  2: 07-11 zsum vector 实例
      L121,  3: 07-11 R#.1    @vector assign
      L138,  4: 07-11 //k 2017-07-11 10:36 zn#1 使用8个值(16.3)来初始化 vector 
      L140,  5: 07-11 //k 2017-07-11 10:37 zn#3 修改值
      L143,  6: 07-11 //k 2017-07-11 10:37 zn#2 附加值
      L147,  7: 07-11 //k 2017-07-11 10:39 zn#5 使用 [] 访问值
      L157,  8: 07-11 //k 2017-07-11 10:38 zn#4 使用 iterator 来遍历 vector 中元素。
      L184,  9: 07-11 R#.3    @vector 
      L190, 10: 07-11 //k 2017-07-11 10:58 zn#6 初始化 vec，10个元素
      L203, 11: 07-11 R#.4    @捕获异常
      L217, 12: 07-11 R#.5    @push_back，自动增长内存
      L232, 13: 07-11 R#.6    @预保留10个字符
      L258, 14: 07-11 R#.7    @设置其中有多少元素
      L277, 15: 07-11 R#.8    @vector 输出
      L279, 16: 07-11 //k 2017-07-11 11:37 zn#7 存放10个元素，且是个元素初始化为0。注意， capacity 不一定是多少。视具体实现而定。
      L281, 17: 07-11 //k 2017-07-11 11:38 zn#8 原来有10个元素；现有11个元素；新加入的元素在数组的结尾的地方
      L287, 18: 07-11 //k 2017-07-11 11:39 zn#9 只是至少保留有这么多空间，并没有放入任何元素。
      L289, 19: 07-11 //k 2017-07-11 11:39 zn#10 放入第一个元素。放入的位置是 [0]
     Zndex_E : //z 17-07-12 18:05:21 L.172'21279 T3694878643.K ~390 --+----+----+----+----+----+
     K   Ter : //z 17-07-11 10:33:47 L.173'48373 T1888754067.K ~0   --+----+----+----+----+----+
     K  Mers : //z 17-07-11 10:33:47 L.173'48373 T1888754067.K ~0   --+----+----+----+----+----+
     K Kersi : //z 17-07-11 10:33:47 L.173'48373 T1888754067.K ~0   --+----+----+----+----+----+
     KVersio : //z 17-07-11 10:33:47 L.173'48373 T1888754067.K ~0   --+----+----+----+----+----+
     K Versi : //z 17-07-11 10:33:47 L.173'48373 T1888754067.K ~0   --+----+----+----+----+----+
     K  Vers : //z 17-07-11 17:44:01 L.173'22559 T2340316978.K ~347     R+.12   L+.460  
     K   Ver : //z 17-07-11 17:00:26 L.173'25174 T2335429617.K ~263     R+.10   L+.418  
     K    Ve : //z 17-07-11 11:25:02 L.173'45298 T3179107852.K ~149     R+.8    L+.285  
     K     V : //z 17-07-11 10:58:43 L.173'46877 T1891305590.K ~73      R+.3    L+.161  
     KaizenZ : //z 17-07-11 10:33:47 L.173'48373 T1888754067.K ~0   --+----+----+----+----+----+
#endregion #HE //z 2017-07-11 10:33:47 L.173'48373 BG57IV3 T1888754067.K.F3385784024-+----+----+

#region 07-11 R#.2    @第2017.07月总结
Month.Plan
	01. 
Month.Done
	01. 
Month.Kaizen
	01. 
	2017-07-11 zsum vector 实例

W26，07-01[六] - 07-02[日]:2 
	01. 
W27，07-03[一] - 07-09[日]:7 
	01. 
W28，07-10[一] - 07-16[日]:7 
	01. 
W29，07-17[一] - 07-23[日]:7 
	01. 
W30，07-24[一] - 07-30[日]:7 
	01. 
W31，07-31[一] - 07-31[一]:1 
	01. 
#endregion //z 2017-07-11 10:52:41 L.173'47239 BG57IV3 T1891089966.K.F3385784024+----+----+----+

#region 07-11 R#.1    @vector assign
01. 
/*
A vector is like an array in many ways, but it is dynamic;
operators such as [] can be used to access elements, and you
can also access elements via a wide range of methods.
*/

#include <vector>
#include <iostream>

using namespace std;

int main ()
{
    vector<float> v;
	
	//k 2017-07-11 10:36 zn#1 使用8个值(16.3)来初始化 vector 
    v.assign( 8, 16.3 );
	//k 2017-07-11 10:37 zn#3 修改值
    v[2] = 16.4;
    v[3] = 20.6;
	//k 2017-07-11 10:37 zn#2 附加值
    v.push_back(17.8);
    v.push_back(-7.3);

	//k 2017-07-11 10:39 zn#5 使用 [] 访问值
    for( int i = 0; i < v.size(); i++ )
    {
        cout << v[i] << " ";
    }

    cout << endl;
	
    cout << v.front() << " "  << v.at(2) << " "  << v.back() << endl;

	//k 2017-07-11 10:38 zn#4 使用 iterator 来遍历 vector 中元素。
    vector<float>::iterator iter;
    for( iter = v.begin(); iter != v.end(); iter++ )
    {
        cout << *iter << endl;
    }
}

/* Sample output

./vec01
16.3 16.3 16.4 20.6 16.3 16.3 16.3 16.3 17.8 -7.3
16.3 16.4 -7.3
16.3
16.3
16.4
20.6
16.3
16.3
16.3
16.3
17.8
-7.3

*/
#endregion //z 2017-07-11 10:33:52 L.173'48368 BG57IV3 T1888754095.K.F3385784024+----+----+----+

#region 07-11 R#.3    @vector 
//z 2017-07-11 10:56:50 L.173'46990 T1891233746.K[T1,L155,R3,V56]
01. 
#include <vector>
//...
size_t size = 10;
//k 2017-07-11 10:58 zn#6 初始化 vec，10个元素
std::vector<int> array(size); // make room for 10 integers,                                 

// and initialize them to 0
// do something with them:
for(int i=0; i<size; ++i)
{
    array[i] = i;
}

// no need to delete anything
#endregion //z 2017-07-11 10:56:48 L.173'46992 BG57IV3 T1891233721.K.F3385784024+----+----+----+

#region 07-11 R#.4    @捕获异常
01. 
std::vector<int> array;

try
{
    array.at(1000) = 0;
}
catch(std::out_of_range o)
{
    std::cout<<o.what()<<std::endl;
}
#endregion //z 2017-07-11 10:58:57 L.173'46863 BG57IV3 T1891305627.K.F3385784024+----+----+----+

#region 07-11 R#.5    @push_back，自动增长内存
01. 
#include <vector>
#include <iostream>
//...
std::vector<char> array;
char c = 0;

while(c != 'x')
{
    std::cin>>c;
    array.push_back(c);
}
#endregion //z 2017-07-11 11:00:49 L.173'46751 BG57IV3 T3176556464.K.F3385784024+----+----+----+

#region 07-11 R#.6    @预保留10个字符
01. 
#include <vector>
#include <iostream>//...s
td::vector<char> array;
array.reserve(10);    // make room for 10 elements
char c = 0;
while(c != 'x')
{
    std::cin>>c;
    array.push_back(c);
}

02.
// snip a:
std::vector<int> v(10);

// snip b:
std::vector<int> v;
v.reserve(10);
这两者是有区别的。虽然最终都保留了10个int元素。但是第一个会调用元素的 ctor ，A中不光放入了10个int元素，还都
调用int的初始化构造函数，将其值初始化为0。

而reserve只保留10个元素的空间。
#endregion //z 2017-07-11 11:01:40 L.173'46700 BG57IV3 T3176592392.K.F3385784024+----+----+----+

#region 07-11 R#.7    @设置其中有多少元素
01. 
#include <vector>
#include <iostream>

//...
std::vector<int> array;
int i = 999;          // some integer value
array.reserve(10);    // make room for 10 elements
array.push_back(i);

std::cout<<array.capacity()<<std::endl;
std::cout<<array.size()<<std::endl;

02. 输出
10
1
#endregion //z 2017-07-11 11:11:36 L.173'46104 BG57IV3 T3177778286.K.F3385784024+----+----+----+

#region 07-11 R#.8    @vector 输出
01. 如下程序的输出以及对应的解释：
//k 2017-07-11 11:37 zn#7 存放10个元素，且是个元素初始化为0。注意， capacity 不一定是多少。视具体实现而定。
vector<int> v(10);
//k 2017-07-11 11:38 zn#8 原来有10个元素；现有11个元素；新加入的元素在数组的结尾的地方
v.push_back(11);

cout << v.size() << " " << v[0] << " capacity " << v.capacity() << endl;

vector<int> v1;
//k 2017-07-11 11:39 zn#9 只是至少保留有这么多空间，并没有放入任何元素。
v1.reserve(10);
//k 2017-07-11 11:39 zn#10 放入第一个元素。放入的位置是 [0]
v1.push_back(11);
cout << v1.size() << " " << v1[0] << " capacity " << v1.capacity() << endl;

02. 输出如下：
11 0 capacity 15
1 11 capacity 10
需要解释下，这两者的的行为差异，详细注释见上。

03. 一旦 size 等于 capacity 后再添加元素，就会引发 reallocation 。
04. 调用 resize 不会所辖 capacity。
#endregion //z 2017-07-11 11:24:03 L.173'45357 BG57IV3 T3179071916.K.F3385784024+----+----+----+

#region 07-11 R#.9    @测试用例
//z 2017-07-11 15:31:45 L.173'30495 T4051054740.K[T2,L305,R9,V209]
01. 
std::vector<int> array;   // create an empty vector
array.reserve(3);         // make room for 3 elements
                          // at this point, capacity() is 3
                          // and size() is 0
array.push_back(999);     // append an element

//k 2017-07-11 16:17 zn#11 resize 会将vec的大小修改为5，然后会fill值；这样会实际变更其大小。
array.resize(5);          // resize the vector
                          // at this point, the vector contains
                          // 999, 0, 0, 0, 0

array.push_back(333);     // append another element into the vector
                          // at this point, the vector contains
                          // 999, 0, 0, 0, 0, 333
array.reserve(1);         // will do nothing, as capacity() > 1

//k 2017-07-11 16:19 zn#12 如果resize的size小于当前的size，那么会变更其内的size，但是 capacity 不会变
array.resize(3);          // at this point, the vector contains
                          // 999, 0, 0
                          // capacity() remains 6
                          // size() is 3

//k 2017-07-11 16:21 zn#13 具有两个参数时会填充1。
array.resize(6, 1);       // resize again, fill up with ones
                          // at this point the vector contains
                          // 999, 0, 0, 1, 1, 1

/*
上述程序输出结果如下。
size : 0 capacity 0

size : 0 capacity 3

size : 1 capacity 3
999

size : 5 capacity 5
999
0
0
0
0

size : 6 capacity 7
999
0
0
0
0
333

size : 6 capacity 7
999
0
0
0
0
333

size : 3 capacity 7
999
0
0

size : 6 capacity 7
999
0
0
1
1
1
*/
#endregion //z 2017-07-11 15:31:41 L.173'30499 BG57IV3 T4051054736.K.F3385784024+----+----+----+

#region 07-11 R#.10   @class X
//z 2017-07-11 16:59:25 L.173'25235 T1050214685.K[T3,L386,R10,V255]
01. 
class X
{
public:
    X():val_(0) {}
    X(int val):val_(val) {}
    int get()
    {
        return val_;
    }
    void set(int val)
    {
        val_=val;
    }
private:
    int val_;
};

//....
std::vector<X> ax; // create an empty vector containing
// objects of type class X
// version 1:
//k 2017-07-11 17:24 zn#14 重置ax大小，会调用 X的默认构造函数10次。
ax.resize(10); // resize the controlled sequence

for(int i=0; i<10; ++i)
{
    ax[i].set(i); // set each element's value
}

//...
// version 2:
ax.reserve(10); // make room for 10 elements；只申请内存空间；不会初始化构造，不变更size大小。
for(int i=0; i<10; ++i)
{
    ax.push_back(X(i)); // insert elements using the second ctor
}
#endregion //z 2017-07-11 16:59:22 L.173'25238 BG57IV3 T1050214682.K.F3385784024+----+----+----+

#region 07-11 R#.11   @使用数组初始化 vector 
01. 
double p[] = {1, 2, 3, 4, 5};
std::vector<double> a(p, p+5);

//k 2017-07-11 17:33 zn#15 在 vector reallocation 之后；指向源地址的指针就失效了。
std::vector<int> v(5);
int *pi = &v[3];
v.push_back(999); // <-- may trigger a reallocation
*pi = 333;        // <-- probably an error, pi isn't valid any more

为避免指针错误，在invalidated了指针之后，避免使用指向内存的指针。
#endregion //z 2017-07-11 17:30:08 L.173'23392 BG57IV3 T2338987316.K.F3385784024+----+----+----+

#region 07-11 R#.12   @iterator
//z 2017-07-11 17:38:31 L.173'22889 T2339274904.K[T4,L446,R12,V320]
01. 
标准概念，iterator，标准库里一个针对容器的通用接口：vector、list、deque、set、stack。
可以用于迭代、查找、排序等操作。

02. 测试 vector 的作用
#include <vector>
#include <iostream>

int main()
{
    std::vector<double> a;
	//k 2017-07-11 17:44 zn#17  一个 const iterator， 没有修改指向的内容的意图。
    std::vector<double>::const_iterator i;

	//k 2017-07-11 17:43 zn#16 使用 iterator 实例
    a.push_back(1);
    a.push_back(2);
    a.push_back(3);
    a.push_back(4);
    a.push_back(5);

    for(i=a.begin(); i!=a.end(); ++i)
    {
        std::cout<<(*i)<<std::endl;
    }
    return 0;
}

03. 虽然如下所示，直接使用指针也能达到同样的效果；但是通过使用 iterator，能够提供一些通用的算法。
#include <vector>
#include <iostream>

int main()
{
    std::vector<double> a;
    const double *p;
    a.push_back(1);
    a.push_back(2);
    a.push_back(3);
    a.push_back(4);
    a.push_back(5);
    for(p=&a[0]; p!=&a[0]+5; ++p)
    {
        std::cout<<(*p)<<std::endl;
    }
    return 0;
}
#endregion //z 2017-07-11 17:38:24 L.173'22896 BG57IV3 T2339274874.K.F3385784024+----+----+----+

#region 07-11 R#.13   @构造函数
//z 2017-07-11 17:47:10 L.173'22370 T2340424821.K[T5,L500,R13,V359]
01. 查看提供的构造函数。
typedef std::vector<std::string> str_vec_t;
//k 2017-07-11 18:04 zn#18 创建一个空的 vector。
str_vec_t v1;                       // create an empty vector
//k 2017-07-11 18:07 zn#19 创建具有10个字符串的vector。
str_vec_t v2(10);                   // 10 copies of empty strings
//k 2017-07-11 18:08 zn#20 10个元素，并且给定了初始值。
str_vec_t v3(10, "hello");          // 10 copies of the string
// "hello"
//k 2017-07-11 18:09 zn#21 copy ctor，可以从其他的 vector 来进行构造。
str_vec_t v4(v3);                   // copy ctor

std::list<std::string> sl;      // create a list of strings
// and populate it
sl.push_back("cat");
sl.push_back("dog");
sl.push_back("mouse");

//k 2017-07-11 18:09 zn#22 使用其他容器的一部分来构造，通过 iterator 。
str_vec_t v5(sl.begin(), sl.end()); // a copy of the range in
// another container
// (here, a list)

//k 2017-07-11 18:10 zn#23 直接赋值
v1 = v5;                            // will copy all elements
// from v5 to v1

02.
size() 告诉你容器中有多少元素，没有告诉容器为它容纳的元素分配了多少内存。

capacity 容器在它已经分配的内存中可以容纳多少元素。当容器满后再次插入将会引发上面的重新分配步骤。

resize 强制把容器大小改为容纳n个元素；调用resize后，size将会返回n。如果n小于当前大小，容器尾部的元素会被销毁。如果n大于当前大小，新默认构造的元素会添加到容器尾部。如果n大于当前容量，在元素加入前

reserve 强制把容器的容量改为至少n，提供的n不小于当前大小，会重分配；否则不改变其大小。
#endregion //z 2017-07-11 17:47:09 L.173'22371 BG57IV3 T2340424797.K.F3385784024+----+----+----+
